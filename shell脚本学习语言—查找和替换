查找文本（匹配）
  1.grep：使用POSIX定义的基本正则表达式（BRE）。单个
  2.egrep：扩展。使用的扩展正则表达式。单个
  3.fgrep：快速。匹配固定字符串。多个
grep：默认使用了-F。-E可替代egrep，-v显示不匹配的行，-s不显示出错信息，-q静默，-l列出匹配模式的行，-i忽略大小写字母
正则表达式：是一种表示方式，让你可以查找匹配特定准则的文本。
由两个基本组成部分所建立：一般字符和特殊字符。特殊字符称为元字符（meta）
  \ :通常用以关闭后续字符的特殊意义。
  . :匹配任何单个的字符，但null除外。
  * :匹配在它之前的任何数目（或没有）的单个字符，
  ^ :匹配紧接着的正则表达式，在行或字符串的起始处。
  $ :匹配前面的正则表达式，在字符串或行结尾处。
  [] :匹配方括号内内的任一字符。连字符（-）指的是连续字符的范围。
  \{n,m\} :区间表达式，匹配在它前面的单个字符重现的次数区间
  \( \) :将其中的模式存储在特殊的“保留空间”。
  \n :重复在\( \)方括号内第n个子模式至此点的模式。
  {n,m} :n到m
  + ：匹配前面正则表达式的一个或多个实例
  ? :匹配前面正则表达式的零个或一个实例
  | :匹配|符号前或后的正则表达式
  () :匹配与方括号括起来的正则表达式群
基本正则表达式（BRE）：
匹配单个字符：在方括号表达式中所有其他的meta字符都会失去其特殊含义。NULL字符不需要是可匹配的。
向后引用：第一步是将子表达式包围在\(与\)里，下一步是在同一模式后使用\digit(1到9的数字)意识是匹配第n个先前方括号内
          子表达式匹配成功的字符。
单个表达式匹配多个字符：*和区间
锚点：^和$，开始或结尾处进行匹配;^$匹配空的字符串或行。
扩展正则表达式（ERE）：
匹配单个字符：awk中其\符号在方括号表达式内表示其他的含义。
向后引用不存在;
匹配单个表达式或多个正则表达式;
交替：交替运算符|或管道字符;
分组：（）;
停驻文本匹配：^和$永远是meta字符;
正则表达式的扩展：\<与\>运算符分别匹配“单词”的开头和结尾;称这类字符为单词组成;
  \w :匹配任何单词组成字符
  \W ：匹配任何非单词组成字符
  \< \> :
  \b :匹配单词的起始或结尾处所找到的空字符串。与\< \>结合使用
  \B :匹配两个单词组成字符之间的空字符串
  \' \` :分别匹配emacs缓冲区的开始和结尾。
  正则表达式查找的最初结果往往就成了要拿来作进一步处理的“原始数据（raw data）”。
  文本替换至少需要做一件事情，就是将一些字以另一些字取代，或者是删除匹配行的某个部分。
  一般来说，执行文本替换的正确程序应该是sed——流编辑器。以批处理的方式来编辑文件。
  使用s命令——要求正则表达式寻找，用替代文本替换匹配的文本，以可选用的标志;-e/-f/-n
  /字符经常扮演定界符，从而分割正则表达式与替代文本，任何可显示的字符都能作为定界符，处理文件名称时，常用标点符号
  在s命令里以g结尾表示的是：全局性，“替代文本取代正则表达式中每一个匹配的”，无则只取代第一个匹配的。
  虽然可以将多个sed实以管道串起来，但是给予sed多个命令是比较容易的，在命令行上，这是通过-e选项的方式来完成。
    每一个编辑命令都使用一个-e选项;
  有时，将编辑命令全放进一个脚本里，再使用sed搭配-f选项会更好。
  sed的工作方式：命令行上的每个文件名会依次打开与读取，如果没有文件，则使用标准输入，文件名“-”可用于表示标准输入。
                sed读取每个文件，一次读一行，将读取的行放进内存的一个区域——称之为模式空间。就像变量：内存的一个区域
                在编辑命令的指示下可以修改，所有编辑上的操作都会应用到模式空间的内容。当所有操作完成后，sed会将模式
                空间的最后内容打印到标准输出，再回到开始处，读取另一个输入行。
-n选项修改了sed的默认行为。sed将不会在操作完成后打印模式空间的最后内容。若在脚本中使用p，将会明白的将此行显示。                
匹配特定行：限制一条命令要应用到哪些行，只要在命令前置一个地址。                


